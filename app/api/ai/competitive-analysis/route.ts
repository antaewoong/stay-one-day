import { NextRequest, NextResponse } from 'next/server'
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { GoogleGenerativeAI } from '@google/generative-ai'

export const dynamic = 'force-dynamic'

interface CompetitiveAnalysis {
  myAccommodation: {
    name: string
    address: string
    price: number
    rating: number
    amenities: string[]
  }
  nearbyCompetitors: {
    name: string
    distance: number
    price: number
    rating: number
    bookingRate: number
    strengths: string[]
    weaknesses: string[]
  }[]
  competitiveAdvantages: {
    category: string
    advantage: string
    impact: 'HIGH' | 'MEDIUM' | 'LOW'
    actionItems: string[]
  }[]
  pricingStrategy: {
    currentPosition: string
    recommendations: {
      strategy: string
      priceRange: { min: number; max: number }
      reasoning: string
      expectedResult: string
    }[]
  }
  marketingFocus: {
    uniqueSellingPoints: string[]
    targetAudience: string[]
    contentStrategy: string[]
    promotionTactics: string[]
  }
  threatAnalysis: {
    immediateThreats: string[]
    opportunityGaps: string[]
    defensiveActions: string[]
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies })
    
    // üîê RLS Ï†ïÏ±Ö Ï§ÄÏàò: Ïù∏Ï¶ù + Í∂åÌïú ÌôïÏù∏
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) {
      return NextResponse.json(
        { error: 'Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌï©ÎãàÎã§' },
        { status: 401 }
      )
    }

    // RLS: ÏÇ¨Ïö©Ïûê Ïó≠Ìï† ÌôïÏù∏
    const { data: userRole } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', session.user.id)
      .single()

    if (!userRole || !['host', 'admin', 'super_admin'].includes(userRole.role)) {
      return NextResponse.json(
        { error: 'Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§' },
        { status: 403 }
      )
    }

    const { accommodationId, radius = 50 } = await request.json()  // Í∏∞Î≥∏ 50km Î∞òÍ≤Ω
    
    if (!accommodationId) {
      return NextResponse.json(
        { error: 'ÏàôÏÜå IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§' },
        { status: 400 }
      )
    }

    // üîê RLS: Ìò∏Ïä§Ìä∏Îäî Î≥∏Ïù∏ ÏàôÏÜåÎßå Î∂ÑÏÑù Í∞ÄÎä•
    if (userRole.role === 'host') {
      const { data: hostData } = await supabase
        .from('hosts')
        .select('id')
        .eq('user_id', session.user.id)
        .single()

      if (!hostData) {
        return NextResponse.json(
          { error: 'Ìò∏Ïä§Ìä∏ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§' },
          { status: 404 }
        )
      }

      // ÏàôÏÜå ÏÜåÏú†Í∂å ÌôïÏù∏
      const { data: accommodation } = await supabase
        .from('accommodations')
        .select('host_id')
        .eq('id', accommodationId)
        .eq('host_id', hostData.id)
        .single()

      if (!accommodation) {
        return NextResponse.json(
          { error: 'Ìï¥Îãπ ÏàôÏÜåÏóê ÎåÄÌïú Í≤ΩÏüÅ Î∂ÑÏÑù Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§' },
          { status: 403 }
        )
      }
    }

    // 1. ÎÇ¥ ÏàôÏÜå Ï†ïÎ≥¥ Ï°∞Ìöå
    const myAccommodation = await getMyAccommodationData(supabase, accommodationId)
    
    // 2. Ï£ºÎ≥Ä Í≤ΩÏüÅÏóÖÏ≤¥ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
    const competitors = await getNearbyCompetitors(supabase, myAccommodation, radius)
    
    // 3. AI Í∏∞Î∞ò Í≤ΩÏüÅ Î∂ÑÏÑù
    const analysis = await generateCompetitiveAnalysis(myAccommodation, competitors)
    
    return NextResponse.json({
      success: true,
      data: {
        analysis,
        generatedAt: new Date().toISOString(),
        analysisRadius: radius
      }
    })
  } catch (error) {
    console.error('Í≤ΩÏüÅ Î∂ÑÏÑù Ïã§Ìå®:', error)
    return NextResponse.json(
      { error: 'Í≤ΩÏüÅ Î∂ÑÏÑù ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§' },
      { status: 500 }
    )
  }
}

async function getMyAccommodationData(supabase: any, accommodationId: string) {
  const { data: accommodation } = await supabase
    .from('accommodations')
    .select(`
      *,
      accommodation_amenities(
        amenities(name)
      ),
      reviews(rating)
    `)
    .eq('id', accommodationId)
    .single()

  if (!accommodation) {
    throw new Error('ÏàôÏÜå Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§')
  }

  // ÌèâÍ∑† ÌèâÏ†ê Í≥ÑÏÇ∞
  const avgRating = accommodation.reviews?.length 
    ? accommodation.reviews.reduce((sum: number, r: any) => sum + r.rating, 0) / accommodation.reviews.length
    : 0

  return {
    id: accommodation.id,
    name: accommodation.name,
    address: accommodation.address,
    region: accommodation.region,
    price: accommodation.base_price,
    rating: avgRating,
    amenities: accommodation.accommodation_amenities?.map((a: any) => a.amenities.name) || [],
    accommodationType: accommodation.accommodation_type,
    maxCapacity: accommodation.max_capacity
  }
}

async function getNearbyCompetitors(supabase: any, myAccommodation: any, radius: number) {
  // ‚≠ê ÏßÑÏßú Í≤ΩÏüÅÎ∂ÑÏÑù: Í∞ôÏùÄ ÏÉÅÏÑ∏ ÏßÄÏó≠Ïùò ÏßÅÏ†ë Í≤ΩÏüÅÏóÖÏ≤¥Îßå
  const { data: competitors } = await supabase
    .from('accommodations')
    .select(`
      *,
      accommodation_amenities(
        amenities(name)
      ),
      reviews(rating),
      reservations(created_at, status)
    `)
    .eq('region', myAccommodation.region)
    .eq('accommodation_type', myAccommodation.accommodationType)  // Í∞ôÏùÄ ÌÉÄÏûÖÎßå
    .gte('max_capacity', myAccommodation.maxCapacity - 2)  // ÎπÑÏä∑Ìïú Í∑úÎ™®Îßå
    .lte('max_capacity', myAccommodation.maxCapacity + 2)
    .eq('status', 'active')
    .neq('id', myAccommodation.id)
    .limit(5)  // ÏßÑÏßú ÏßÅÏ†ë Í≤ΩÏüÅÏóÖÏ≤¥ 5Í∞úÎßå

  return competitors?.map((comp: any) => {
    // ÏòàÏïΩÎ•† Í≥ÑÏÇ∞ (ÏµúÍ∑º 30Ïùº)
    const recentReservations = comp.reservations?.filter((r: any) => {
      const createdDate = new Date(r.created_at)
      const thirtyDaysAgo = new Date()
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
      return createdDate >= thirtyDaysAgo && r.status === 'confirmed'
    }) || []

    const avgRating = comp.reviews?.length 
      ? comp.reviews.reduce((sum: number, r: any) => sum + r.rating, 0) / comp.reviews.length
      : 0

    return {
      id: comp.id,
      name: comp.name,
      distance: calculateRegionDistance(myAccommodation.region, comp.region), // ÏßÄÏó≠ Í∏∞Î∞ò Í±∞Î¶¨ Ï∂îÏ†ï
      price: comp.base_price,
      rating: avgRating,
      bookingRate: recentReservations.length / 30 * 100, // ÏùºÏùº ÌèâÍ∑† ÏòàÏïΩÎ•†
      amenities: comp.accommodation_amenities?.map((a: any) => a.amenities.name) || [],
      accommodationType: comp.accommodation_type,
      maxCapacity: comp.max_capacity
    }
  }) || []
}

async function generateCompetitiveAnalysis(
  myAccommodation: any, 
  competitors: any[]
): Promise<CompetitiveAnalysis> {
  const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!)
  const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })

  const prompt = `
    ÎãπÏã†ÏùÄ ÏàôÎ∞ïÏóÖÍ≥Ñ ÌòÑÏû• Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§. ${myAccommodation.region}ÏóêÏÑú ÏßÅÏ†ë Í≤ΩÏüÅÌïòÎäî ÏóÖÏ≤¥Îì§Í≥ºÏùò ÏπòÏó¥Ìïú Í≤ΩÏüÅÏóêÏÑú Ïù¥Í∏∞Îäî Ï†ÑÎûµÏùÑ Ï†úÏïàÌï¥Ï£ºÏÑ∏Ïöî.

    ## üè† Ïö∞Î¶¨ ÏàôÏÜå:
    - ${myAccommodation.name} (${myAccommodation.region})
    - Í∞ÄÍ≤©: ${myAccommodation.price.toLocaleString()}Ïõê/Î∞ï
    - ÌèâÏ†ê: ${myAccommodation.rating.toFixed(1)}/5.0Ï†ê
    - Ìé∏ÏùòÏãúÏÑ§: ${myAccommodation.amenities.join(', ')}
    - ÏµúÎåÄ ${myAccommodation.maxCapacity}Î™Ö ÏàòÏö©

    ## ‚öîÔ∏è Î∞îÎ°ú ÏòÜ ÏßÅÏ†ë Í≤ΩÏüÅÏóÖÏ≤¥Îì§:
    ${competitors.map(comp => `
    ‚Ä¢ ${comp.name}: ${comp.price.toLocaleString()}Ïõê/Î∞ï, ‚≠ê${comp.rating.toFixed(1)}Ï†ê, üìàÏòàÏïΩÎ•† ${comp.bookingRate.toFixed(1)}%
    `).join('')}

    ## üéØ Í∏¥Í∏â Ï†ÑÎûµ ÏàòÎ¶Ω:
    **ÏÉÅÌô©**: ${myAccommodation.region} ÏßÄÏó≠ÏóêÏÑú Í∞ôÏùÄ Í≥†Í∞ùÏùÑ ÎëêÍ≥† Í≤ΩÏüÅ Ï§ë
    
    **Î∂ÑÏÑù ÏöîÏ≤≠**:
    1. üî• Í∞Å Í≤ΩÏüÅÏóÖÏ≤¥Î≥Ñ "Ïñ¥ÎñªÍ≤å Ïù¥Í∏∏ÏßÄ" Íµ¨Ï≤¥Ï†Å Î∞©Î≤ï
    2. üí∞ Ïö∞Î¶¨Í∞Ä ÏÑ§Ï†ïÌï¥Ïïº Ìï† ÏµúÏ†Å Í∞ÄÍ≤© (Í≤ΩÏüÅÏóÖÏ≤¥ ÎåÄÎπÑ)
    3. üì¢ Í≥†Í∞ùÏù¥ Ïö∞Î¶¨Î•º ÏÑ†ÌÉùÌïòÍ≤å ÎßåÎìúÎäî Ï∞®Î≥ÑÌôî Ìè¨Ïù∏Ìä∏
    4. ‚ö° ÎÇ¥ÏùºÎ∂ÄÌÑ∞ ÎãπÏû• Ïã§Ìñâ Í∞ÄÎä•Ìïú Ïï°ÏÖò 3Í∞ÄÏßÄ
    5. üõ°Ô∏è Í≤ΩÏüÅÏóÖÏ≤¥Í∞Ä Îî∞ÎùºÌïòÍ∏∞ Ïñ¥Î†§Ïö¥ Ïö∞Î¶¨ÎßåÏùò Ïû•Ï†ê

    **Î™©Ìëú**: Ïù¥ ÏßÄÏó≠ÏóêÏÑú ÏòàÏïΩ 1Îì± Îã¨ÏÑ±ÌïòÍ∏∞

    Î∞òÎìúÏãú JSON ÌòïÌÉúÎ°ú Ïã§Ï†Ñ Ï†ÑÎûµÏùÑ Ï†úÍ≥µÌïòÏÑ∏Ïöî.
  `

  try {
    const result = await model.generateContent(prompt)
    const analysisText = result.response.text()
    
    // JSON ÌååÏã± ÏãúÎèÑ
    const jsonMatch = analysisText.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0])
    }
    
    // JSON ÌååÏã± Ïã§Ìå® Ïãú Í∏∞Î≥∏ Î∂ÑÏÑù Î∞òÌôò
    return generateDefaultCompetitiveAnalysis(myAccommodation, competitors)
  } catch (error) {
    console.error('AI Í≤ΩÏüÅ Î∂ÑÏÑù Ïã§Ìå®:', error)
    return generateDefaultCompetitiveAnalysis(myAccommodation, competitors)
  }
}

function generateDefaultCompetitiveAnalysis(
  myAccommodation: any, 
  competitors: any[]
): CompetitiveAnalysis {
  const avgCompetitorPrice = competitors.reduce((sum, c) => sum + c.price, 0) / competitors.length
  const avgCompetitorRating = competitors.reduce((sum, c) => sum + c.rating, 0) / competitors.length

  return {
    myAccommodation: {
      name: myAccommodation.name,
      address: myAccommodation.address,
      price: myAccommodation.price,
      rating: myAccommodation.rating,
      amenities: myAccommodation.amenities
    },
    nearbyCompetitors: competitors.map(comp => ({
      name: comp.name,
      distance: comp.distance,
      price: comp.price,
      rating: comp.rating,
      bookingRate: comp.bookingRate,
      strengths: generateStrengths(comp, myAccommodation),
      weaknesses: generateWeaknesses(comp, myAccommodation)
    })),
    competitiveAdvantages: [
      {
        category: 'Í∞ÄÍ≤© Í≤ΩÏüÅÎ†•',
        advantage: myAccommodation.price < avgCompetitorPrice 
          ? 'ÌèâÍ∑†Î≥¥Îã§ Ï†ÄÎ†¥Ìïú Í∞ÄÍ≤©ÏúºÎ°ú Í∞ÄÏÑ±ÎπÑ Ïö∞ÏúÑ'
          : 'ÌîÑÎ¶¨ÎØ∏ÏóÑ Í∞ÄÍ≤©ÏúºÎ°ú Í≥†ÌíàÏßà Ïù¥ÎØ∏ÏßÄ',
        impact: 'HIGH',
        actionItems: [
          'Í∞ÄÍ≤© ÎåÄÎπÑ Í∞ÄÏπò Í∞ïÏ°∞ ÎßàÏºÄÌåÖ',
          'ÏãúÏ¶åÎ≥Ñ ÎèôÏ†Å Í∞ÄÍ≤© Ï†ÑÎûµ ÎèÑÏûÖ',
          'Ìå®ÌÇ§ÏßÄ ÏÉÅÌíà Í∞úÎ∞ú'
        ]
      },
      {
        category: 'ÏÑúÎπÑÏä§ Ï∞®Î≥ÑÌôî',
        advantage: 'ÎèÖÌäπÌïú Ìé∏ÏùòÏãúÏÑ§Í≥º Í∞úÏù∏ÌôîÎêú ÏÑúÎπÑÏä§',
        impact: 'MEDIUM',
        actionItems: [
          'Í≥†Ïú† Ìé∏ÏùòÏãúÏÑ§ ÌôçÎ≥¥ Í∞ïÌôî',
          'ÎßûÏ∂§Ìòï ÏÑúÎπÑÏä§ Í∞úÎ∞ú',
          'Í≥†Í∞ù Î¶¨Î∑∞ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú'
        ]
      }
    ],
    pricingStrategy: {
      currentPosition: myAccommodation.price < avgCompetitorPrice ? 'Í∞ÄÏÑ±ÎπÑ Ìè¨ÏßÄÏÖò' : 'ÌîÑÎ¶¨ÎØ∏ÏóÑ Ìè¨ÏßÄÏÖò',
      recommendations: [
        {
          strategy: 'ÎèôÏ†Å Í∞ÄÍ≤© Ï†ÑÎûµ',
          priceRange: {
            min: Math.floor(avgCompetitorPrice * 0.8),
            max: Math.ceil(avgCompetitorPrice * 1.2)
          },
          reasoning: 'ÏàòÏöîÏôÄ Í≤ΩÏüÅ ÏÉÅÌô©Ïóê Îî∞Î•∏ ÌÉÑÎ†•Ï†Å Í∞ÄÍ≤© Ï°∞Ï†ï',
          expectedResult: 'ÏòàÏïΩÎ•† 15-25% Ìñ•ÏÉÅ ÏòàÏÉÅ'
        }
      ]
    },
    marketingFocus: {
      uniqueSellingPoints: [
        'ÏßÄÏó≠ ÏµúÍ≥†Ïùò Ìé∏ÏùòÏãúÏÑ§',
        'Í∞úÏù∏ÌôîÎêú ÎßûÏ∂§ ÏÑúÎπÑÏä§',
        'ÏµúÏ†ÅÏùò ÏúÑÏπòÏôÄ Ï†ëÍ∑ºÏÑ±'
      ],
      targetAudience: [
        '20-30ÎåÄ Ïª§Ìîå',
        'Í∞ÄÏ°± Îã®ÏúÑ Ïó¨ÌñâÍ∞ù',
        'ÎπÑÏ¶àÎãàÏä§ Ï∂úÏû•Í∞ù'
      ],
      contentStrategy: [
        'Ïã§Ï†ú Ïù¥Ïö© ÌõÑÍ∏∞ Ï§ëÏã¨ ÏΩòÌÖêÏ∏†',
        'ÏßÄÏó≠ Î™ÖÏÜåÏôÄ Ïó∞Í≥ÑÌïú Ïó¨Ìñâ Í∞ÄÏù¥Îìú',
        'SNS ÏπúÌôîÏ†Å Ìè¨ÌÜ†Ï°¥ ÌôúÏö©'
      ],
      promotionTactics: [
        'Ï≤´ Î∞©Î¨∏ Í≥†Í∞ù Ìï†Ïù∏',
        'Ïû•Í∏∞ ÏàôÎ∞ï Ìå®ÌÇ§ÏßÄ',
        'ÏßÄÏó≠ ÌååÌä∏ÎÑàÏã≠ ÌòúÌÉù'
      ]
    },
    threatAnalysis: {
      immediateThreats: [
        'ÏÉàÎ°úÏö¥ Í≤ΩÏüÅÏóÖÏ≤¥ ÏßÑÏûÖ',
        'Í∏∞Ï°¥ ÏóÖÏ≤¥Ïùò Í∞ÄÍ≤© Ïù∏Ìïò',
        'Í≥ÑÏ†àÏ†Å ÏàòÏöî Î≥ÄÎèô'
      ],
      opportunityGaps: [
        'Ï∞®Î≥ÑÌôîÎêú ÏÑúÎπÑÏä§ Î∂ÄÏ°±',
        'ÎîîÏßÄÌÑ∏ ÎßàÏºÄÌåÖ ÎØ∏Ìù°',
        'Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÌôúÏö© Î∂ÄÏ°±'
      ],
      defensiveActions: [
        'Í≥†Í∞ù Ï∂©ÏÑ±ÎèÑ ÌîÑÎ°úÍ∑∏Îû® ÎèÑÏûÖ',
        'ÏÑúÎπÑÏä§ ÌíàÏßà ÏßÄÏÜçÏ†Å Í∞úÏÑ†',
        'ÎßàÏºÄÌåÖ ÏûêÎèôÌôî ÏãúÏä§ÌÖú Íµ¨Ï∂ï'
      ]
    }
  }
}

function generateStrengths(competitor: any, myAccommodation: any): string[] {
  const strengths = []
  
  if (competitor.price < myAccommodation.price) {
    strengths.push('Îçî Ï†ÄÎ†¥Ìïú Í∞ÄÍ≤©')
  }
  if (competitor.rating > myAccommodation.rating) {
    strengths.push('ÎÜíÏùÄ Í≥†Í∞ù ÎßåÏ°±ÎèÑ')
  }
  if (competitor.bookingRate > 50) {
    strengths.push('ÎÜíÏùÄ ÏòàÏïΩÎ•†')
  }
  
  return strengths.length ? strengths : ['Í∏∞Î≥∏Ï†ÅÏù∏ ÏãúÏÑ§ Ï†úÍ≥µ']
}

function generateWeaknesses(competitor: any, myAccommodation: any): string[] {
  const weaknesses = []
  
  if (competitor.price > myAccommodation.price) {
    weaknesses.push('ÏÉÅÎåÄÏ†ÅÏúºÎ°ú ÎÜíÏùÄ Í∞ÄÍ≤©')
  }
  if (competitor.rating < myAccommodation.rating) {
    weaknesses.push('ÎÇÆÏùÄ Í≥†Í∞ù ÌèâÏ†ê')
  }
  if (competitor.bookingRate < 30) {
    weaknesses.push('ÎÇÆÏùÄ ÏòàÏïΩÎ•†')
  }
  
  return weaknesses.length ? weaknesses : ['ÏùºÎ∞òÏ†ÅÏù∏ ÏÑúÎπÑÏä§']
}

// üó∫Ô∏è ÏßÄÏó≠ Í∏∞Î∞ò Í±∞Î¶¨ Ï∂îÏ†ï Ìï®Ïàò
function calculateRegionDistance(region1: string, region2: string): number {
  // Í∞ôÏùÄ ÏßÄÏó≠Ïù¥Î©¥ Îß§Ïö∞ Í∞ÄÍπåÏõÄ
  if (region1 === region2) {
    return Math.random() * 10 + 1 // 1-10km ÎÇ¥
  }
  
  // ÏßÄÏó≠Î™Ö Í∏∞Î∞ò ÎåÄÎûµÏ†Å Í±∞Î¶¨ Ï∂îÏ†ï
  const regionDistanceMap: { [key: string]: { [key: string]: number } } = {
    'Í∞ïÎÇ®Íµ¨': { 'ÏÑúÏ¥àÍµ¨': 8, 'ÏÜ°ÌååÍµ¨': 12, 'Ïö©ÏÇ∞Íµ¨': 15, 'ÎßàÌè¨Íµ¨': 20 },
    'Ï†úÏ£ºÏãú': { 'ÏÑúÍ∑ÄÌè¨Ïãú': 35, 'Í∞ïÎÇ®Íµ¨': 450 },
    'Ï≤≠Ï£ºÏãú': { 'ÎåÄÏ†ÑÏãú': 45, 'ÏÑúÏö∏Ïãú': 120 },
    'Í≤ΩÏ£ºÏãú': { 'Î∂ÄÏÇ∞Ïãú': 60, 'ÎåÄÍµ¨Ïãú': 80 },
    'Ï∂òÏ≤úÏãú': { 'ÏÑúÏö∏Ïãú': 85, 'Ïù∏Ï≤úÏãú': 95 }
  }
  
  // Îß§ÌïëÎêú Í±∞Î¶¨Í∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©
  if (regionDistanceMap[region1] && regionDistanceMap[region1][region2]) {
    return regionDistanceMap[region1][region2]
  }
  if (regionDistanceMap[region2] && regionDistanceMap[region2][region1]) {
    return regionDistanceMap[region2][region1]
  }
  
  // Í∏∞Î≥∏Í∞í: 50km Ïù¥ÎÇ¥Î°ú Í∞ÄÏ†ï
  return Math.random() * 45 + 5 // 5-50km
}